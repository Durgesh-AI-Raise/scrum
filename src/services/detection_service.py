import json\nimport boto3\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict\nfrom src.services.policy_service import PolicyServiceAPI # Import the actual PolicyServiceAPI\nfrom src.models.review import Review # Import Review model\n\nclass DetectionService:\n    def __init__(self, dynamodb_table_name: str, policy_service_api=None, aws_region: str = 'us-east-1'):\n        self.dynamodb_resource = boto3.resource('dynamodb', region_name=aws_region)\n        self.reviews_table = self.dynamodb_resource.Table(dynamodb_table_name)\n        self.policy_service_api = policy_service_api if policy_service_api else PolicyServiceAPI() # Use actual API\n        self.active_criteria = []\n        self._load_criteria()\n        print(f\"Initialized Detection Service for DynamoDB Table: {dynamodb_table_name}\")\n\n    def _load_criteria(self):\n        criteria, status = self.policy_service_api.get_all_active_criteria()\n        if status == 200:\n            self.active_criteria = criteria\n            print(f\"Loaded {len(self.active_criteria)} active abuse criteria.\")\n        else:\n            print(f\"Failed to load abuse criteria: Status {status}\")\n\n    def _check_keyword_pattern(self, review_text: str, criteria_details: dict) -> (bool, str):\n        keywords = criteria_details.get('keywords', [])\n        match_type = criteria_details.get('match_type', 'contains') # 'exact_phrase' or 'contains'\n\n        for keyword in keywords:\n            if match_type == 'exact_phrase':\n                # Simple exact phrase check, normalize for better matching if needed\n                if f\" {keyword.lower()} \" in f\" {review_text.lower()} \":\n                    return True, f\"Matched exact phrase: '{keyword}'\"\n            elif match_type == 'contains':\n                if keyword.lower() in review_text.lower():\n                    return True, f\"Contained keyword: '{keyword}'\"\n        return False, \"\"\n\n    def _check_review_frequency(self, review_data: dict, criteria_details: dict) -> (bool, str):\n        reviewer_id = review_data.get('reviewerId')\n        max_reviews_in_24h = criteria_details.get('max_reviews_in_24h')\n        reviewer_id_key = criteria_details.get('reviewer_id_key', 'reviewerId')\n\n        if not reviewer_id or not max_reviews_in_24h:\n            return False, \"Insufficient data for frequency check or missing configuration.\"\n\n        # Query DynamoDB using the GSI for reviewerId\n        try:\n            # Calculate time 24 hours ago\n            time_24_hours_ago = (datetime.utcnow() - timedelta(hours=24)).isoformat()\n\n            response = self.reviews_table.query(\n                IndexName='ReviewerIdIndex',\n                KeyConditionExpression=boto3.dynamodb.conditions.Key(reviewer_id_key).eq(reviewer_id),\n                FilterExpression=boto3.dynamodb.conditions.Attr('ingestedAt').gt(time_24_hours_ago) # Use ingestedAt for recency\n            )\n            recent_reviews = response.get('Items', [])\n            # Exclude the current review from the count if it's already in DB and being re-processed\n            # For a new review, this count includes previous reviews by the same user\n            if len(recent_reviews) > max_reviews_in_24h:\n                return True, f\"Reviewer '{reviewer_id}' posted {len(recent_reviews)} reviews in last 24h (max allowed: {max_reviews_in_24h})\"\n        except self.reviews_table.meta.client.exceptions.ResourceNotFoundException:\n            print(f\"Warning: ReviewerIdIndex not found. Cannot perform frequency check for {reviewer_id}.\")\n            return False, \"Frequency check skipped: Index not available.\"\n        except Exception as e:\n            print(f\"Error during frequency check for reviewer {reviewer_id}: {e}\")\n            return False, \"Failed to perform frequency check due to system error.\"\n\n        return False, \"\"\n\n    # Add more rule types here as needed\n    # def _check_identical_phrases(self, review_data: dict, criteria_details: dict) -> (bool, str):\n    #     # Implementation for text similarity\n    #     pass\n\n    def process_review_for_detection(self, review_data: dict):\n        review_id = review_data.get('reviewId')\n        review_text = review_data.get('reviewText', '')\n        reviewer_id = review_data.get('reviewerId')\n\n        if not review_id:\n            print(\"Review data missing 'reviewId', skipping detection.\")\n            return\n\n        flagging_reasons = []\n        confidence_score = 0.0\n\n        for criteria in self.active_criteria:\n            rule_id = criteria['id']\n            rule_name = criteria['name']\n            rule_type = criteria['type']\n            criteria_details = criteria['criteria_details']\n\n            is_flagged = False\n            reason = \"\"\n\n            if rule_type == \"KEYWORD_PATTERN\":\n                is_flagged, reason = self._check_keyword_pattern(review_text, criteria_details)\n            elif rule_type == \"REVIEW_FREQUENCY\":\n                is_flagged, reason = self._check_review_frequency(review_data, criteria_details)\n            # Add calls to other rule type checks here\n\n            if is_flagged:\n                flagging_reasons.append({\"ruleId\": rule_id, \"ruleName\": rule_name, \"reason\": reason})\n                confidence_score += 0.5 # Simple additive score for now, can be weighted later\n\n        if flagging_reasons:\n            print(f\"Review {review_id} flagged! Reasons: {flagging_reasons}\")\n            self.reviews_table.update_item(\n                Key={'reviewId': review_id},\n                UpdateExpression=\"SET flaggedStatus = :fs, flaggingReasons = :fr, confidenceScore = :cs, lastFlaggedAt = :lfa, #s = :status_processed\",\n                ExpressionAttributeNames={\n                    '#s': 'status' # Use expression attribute names to avoid conflict with reserved keyword 'status'\n                },\n                ExpressionAttributeValues={\n                    ':fs': 'FLAGGED',\n                    ':fr': flagging_reasons,\n                    ':cs': min(confidence_score, 1.0), # Cap score at 1.0\n                    ':lfa': datetime.utcnow().isoformat(),\n                    ':status_processed': 'PROCESSED' # Mark as processed after detection\n                }\n            )\n            print(f\"Updated review {review_id} with flagging status.\")\n        else:\n            print(f\"Review {review_id} passed all active detection rules.\")\n            # If it was previously flagged, and now passes, we might want to change it back to CLEAN\n            # For MVP, we'll ensure it's marked as PROCESSED.\n            self.reviews_table.update_item(\n                Key={'reviewId': review_id},\n                UpdateExpression=\"SET #s = :status_processed, flaggedStatus = :fs_clean\",\n                ExpressionAttributeNames={\n                    '#s': 'status' # Use expression attribute names to avoid conflict with reserved keyword 'status'\n                },\n                ExpressionAttributeValues={\n                    ':status_processed': 'PROCESSED',\n                    ':fs_clean': 'CLEAN'\n                }\n            )\n            print(f\"Review {review_id} marked as CLEAN and PROCESSED.\")\n\n\n# Example usage in a Lambda handler or as part of a streaming application\ndef lambda_handler(event, context):\n    DYNAMODB_TABLE = os.getenv('DYNAMODB_TABLE_NAME', 'AmazonReviews')\n    AWS_REGION = os.getenv('AWS_REGION', 'us-east-1')\n    \n    # Initialize DetectionService (ideally outside handler for warm starts)\n    detection_service = DetectionService(DYNAMODB_TABLE, aws_region=AWS_REGION)\n\n    for record in event['Records']:\n        # Assuming Kinesis event structure (if triggered by Kinesis)\n        if 'kinesis' in record:\n            payload = json.loads(record['kinesis']['data'].decode('utf-8'))\n            print(f\"Processing Kinesis record: {payload}\")\n            detection_service.process_review_for_detection(payload)\n        # Add DynamoDB Streams event handling (if triggered by DynamoDB stream on new ingestion)\n        elif 'dynamodb' in record:\n            if record['eventName'] == 'INSERT' or record['eventName'] == 'MODIFY':\n                new_image = record['dynamodb']['NewImage']\n                # DynamoDB Stream images are in DynamoDB JSON format, convert to regular Python dict\n                # and unwrap S (String), N (Number) types etc.\n                review_data = {k: list(v.values())[0] for k, v in new_image.items()}\n                print(f\"Processing DynamoDB Stream record: {review_data}\")\n                detection_service.process_review_for_detection(review_data)\n\n    return {'statusCode': 200, 'body': 'Detection process complete'}\n\n\nif __name__ == '__main__':\n    # Manual test of detection service\n    DYNAMODB_TABLE = os.getenv('DYNAMODB_TABLE_NAME', 'AmazonReviews')\n    AWS_REGION = os.getenv('AWS_REGION', 'us-east-1')\n    \n    # For local testing, ensure a DynamoDB table named 'AmazonReviews' exists\n    # with 'reviewId' as PK, and GSIs for 'reviewerId' and 'flaggedStatus'.\n    # Run src/infrastructure/dynamodb_setup.py first if needed.\n\n    # Dummy PolicyServiceAPI for local test if real one is not running\n    # If you want to use the actual PolicyServiceAPI, ensure its 'criteria.json' is loaded\n    # and the PolicyServiceAPI instance is configured to use the same criteria_store.\n    class LocalTestPolicyServiceAPI(PolicyServiceAPI):\n        def __init__(self):\n            super().__init__() # Initializes with an empty criteria_store\n            # Manually load criteria for local testing\n            config_path = 'config/criteria.json' # Adjust path as necessary\n            try:\n                with open(config_path, 'r') as f:\n                    criteria_list = json.load(f)\n                for criteria_data in criteria_list:\n                    self.create_criteria(criteria_data) # Use the create method to populate\n                print(f\"Loaded {len(criteria_list)} criteria from {config_path} for local test.\")\n            except FileNotFoundError:\n                print(f\"Warning: {config_path} not found. Using default empty criteria for local test.\")\n            except Exception as e:\n                print(f\"Error loading criteria for local test: {e}\")\n\n    policy_api_for_test = LocalTestPolicyServiceAPI()\n    detection_service = DetectionService(DYNAMODB_TABLE, policy_service_api=policy_api_for_test, aws_region=AWS_REGION)\n    \n    # Create a dummy review (mimicking what ingestion service would store)\n    # These should match the Review model fields\n    test_review_1_data = {\n        \"reviewId\": \"test-review-1001\",\n        \"productId\": \"prod-abc\",\        \"reviewerId\": \"reviewer-xyz\",\
        \"rating\": 1,\n        \"reviewText\": \"This product is a total scam and a fraud! Very bad.\",\
        \"reviewDate\": (datetime.utcnow() - timedelta(hours=2)).isoformat(), # 2 hours ago\
        \"ingestedAt\": (datetime.utcnow() - timedelta(hours=2)).isoformat(),\
        \"status\": \"INGESTED\"\
    }\n    \n    test_review_2_data = {\n        \"reviewId\": \"test-review-1002\",\n        \"productId\": \"prod-def\",\
        \"reviewerId\": \"reviewer-xyz\", # Same reviewer as above for frequency check\
        \"rating\": 5,\n        \"reviewText\": \"Great product, highly recommend.\",\
        \"reviewDate\": (datetime.utcnow() - timedelta(hours=1)).isoformat(), # 1 hour ago\
        \"ingestedAt\": (datetime.utcnow() - timedelta(hours=1)).isoformat(),\
        \"status\": \"INGESTED\"\
    }\n\n    test_review_3_data = {\n        \"reviewId\": \"test-review-1003\",\n        \"productId\": \"prod-ghi\",\
        \"reviewerId\": \"reviewer-pqr\",\
        \"rating\": 2,\n        \"reviewText\": \"Bad bad bad. What a bad product.\",\
        \"reviewDate\": datetime.utcnow().isoformat(),\
        \"ingestedAt\": datetime.utcnow().isoformat(),\
        \"status\": \"INGESTED\"\
    }\n\n    # Simulate writing to DynamoDB first (usually done by ingestion service)\n    try:\n        reviews_table_test = detection_service.reviews_table\n        \n        # Store dummy reviews to simulate data\n        reviews_table_test.put_item(Item=test_review_1_data)\n        print(f\"Simulated ingestion of {test_review_1_data['reviewId']}\")\n        reviews_table_test.put_item(Item=test_review_2_data)\n        print(f\"Simulated ingestion of {test_review_2_data['reviewId']}\")\n        reviews_table_test.put_item(Item=test_review_3_data)\n        print(f\"Simulated ingestion of {test_review_3_data['reviewId']}\")\n\n        # Now, run detection\n        print(\"\\n--- Running detection for Test Review 1 --- \")\n        detection_service.process_review_for_detection(test_review_1_data)\n        \n        print(\"\\n--- Running detection for Test Review 2 (should not flag for frequency yet) ---\")\n        detection_service.process_review_for_detection(test_review_2_data)\n\n        print(\"\\n--- Running detection for Test Review 3 ---\")\n        detection_service.process_review_for_detection(test_review_3_data)\n\n        # Simulate a rapid-fire review for reviewer-xyz to trigger frequency rule\n        # Add more reviews for 'reviewer-xyz' to trigger the frequency rule\n        for i in range(3, 8): # This will make total reviews 2 + 5 = 7 (exceeds 5) for reviewer-xyz\n            rapid_review_data = {\n                \"reviewId\": f\"test-review-100{i}\",\n                \"productId\": f\"prod-rapid-{i}\",\n                \"reviewerId\": \"reviewer-xyz\",\n                \"rating\": 4,\n                \"reviewText\": f\"Another review from reviewer-xyz {i}.\",\n                \"reviewDate\": datetime.utcnow().isoformat(),\n                \"ingestedAt\": datetime.utcnow().isoformat(),\n                \"status\": \"INGESTED\"\n            }\n            reviews_table_test.put_item(Item=rapid_review_data)\n            print(f\"Simulated rapid ingestion of {rapid_review_data['reviewId']}\")\n            detection_service.process_review_for_detection(rapid_review_data)\n\n\n        # Verify updates (manually check DynamoDB or fetch updated items)\n        updated_review_1 = reviews_table_test.get_item(Key={'reviewId': test_review_1_data['reviewId']}).get('Item')\n        print(f\"\\nUpdated Review 1: {updated_review_1}\")\n\n        updated_review_2 = reviews_table_test.get_item(Key={'reviewId': test_review_2_data['reviewId']}).get('Item')\n        print(f\"Updated Review 2: {updated_review_2}\")\n\n        # Check one of the rapid-fire reviews that should now be flagged\n        last_rapid_review_id = f\"test-review-100{7}\"\n        updated_rapid_review = reviews_table_test.get_item(Key={'reviewId': last_rapid_review_id}).get('Item')\n        print(f\"Updated Last Rapid Review ({last_rapid_review_id}): {updated_rapid_review}\")\n\n    except Exception as e:\n        print(f\"Error during local detection service test: {e}\")\n        print(\"Make sure DynamoDB table 'AmazonReviews' exists and you have AWS credentials configured.\")\n