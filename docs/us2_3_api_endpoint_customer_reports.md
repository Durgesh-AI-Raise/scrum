## Sprint Backlog - User Story 2.3: Develop API endpoint for receiving customer reports

### Implementation Plan
*   **Create API Endpoint:** Develop a new API endpoint, `/api/report-abuse`, within a new or existing backend service, `CustomerReportingService`. This endpoint will exclusively handle `POST` requests.
*   **Request Parsing:** Parse the incoming JSON payload from the front-end, extracting `review_id`, `reason`, `comment` (optional), and `reporting_user_id` (optional).
*   **Basic Validation:** Implement initial validation to ensure required fields (`review_id`, `reason`) are present and non-empty. For `reason`, check against a predefined list of valid reasons. (More comprehensive validation will be covered in US2.5).
*   **Generate Report Metadata:** Generate a unique `report_id` (UUID) and a `report_timestamp` (UTC now) for each incoming report.
*   **Publish to Message Queue:** Publish the validated report data, along with generated metadata, to a dedicated message queue topic (e.g., `customer_abuse_reports_events`). This ensures asynchronous processing and decouples the API from downstream storage logic.
*   **Return Response:** Send an appropriate HTTP 202 (Accepted) response to the client, indicating that the report has been received and is being processed.

### Data Models
*   **`CustomerReportRequest` (Received by API):**
    ```json
    {
        "review_id": "string",           // The ID of the review being reported
        "reason": "string",              // e.g., "spam", "offensive", "fake", "irrelevant", "other"
        "comment": "string",             // Optional detailed comment from the user
        "reporting_user_id": "string",   // Optional, ID of the user submitting the report (if logged in)
        "report_timestamp": "string"     // Optional, ISO 8601 datetime (can be generated by backend if not provided)
    }
    ```
*   **`CustomerReportEvent` (Published to Message Queue):**
    ```python
    class CustomerReportEvent:
        report_id: str               // Unique ID generated for this specific report
        review_id: str
        reason: str
        comment: Optional[str]
        reporting_user_id: Optional[str]
        report_timestamp: datetime   // Server-side generated UTC timestamp
        # Potentially add source_ip, user_agent from request for additional context/abuse prevention
    ```

### Architecture
*   **`CustomerReportingService`:** A new, independent Python-based microservice (e.g., using Flask or FastAPI). This service will expose the `/api/report-abuse` endpoint.
*   **API Gateway (Implicit):** Assumed to be in front of the microservice, routing incoming report requests.
*   **Message Queue (Kafka/RabbitMQ):** Serves as a central communication bus. The `CustomerReportingService` will act as a producer for `customer_abuse_reports_events`.

### Assumptions/Technical Decisions
*   The API endpoint will eventually be secured with appropriate authentication and authorization mechanisms (e.g., JWT for logged-in users, or rate-limiting/CAPTCHA for anonymous submissions) to prevent abuse. For MVP, this security is simplified.
*   Reports are processed asynchronously. The API will respond quickly after publishing to the message queue, without waiting for the report to be stored.
*   The `report_id` will be a UUID generated by the `CustomerReportingService` to ensure uniqueness across all reports.
*   The `report_timestamp` will be generated server-side for reliability, capturing the exact time the report was received by the backend.
*   Standard HTTP status codes will be used for responses (202 for success, 400 for bad requests).
*   The service will be designed to be stateless to allow for easy horizontal scaling.

### Code Snippets/Pseudocode (`app/api/customer_reporting_api.py`)
```python
from flask import Flask, request, jsonify
from datetime import datetime
import uuid
import json
from typing import Optional

app = Flask(__name__)

# Placeholder for a message queue producer
# from some_mq_library import MessageQueueProducer
# mq_producer = MessageQueueProducer('customer_abuse_reports_events')

@app.route('/api/report-abuse', methods=['POST'])
def report_abuse():
    data = request.get_json()

    # 1. Basic Input Validation (more robust validation in US2.5)
    required_fields = ['review_id', 'reason']
    if not all(field in data and data[field] for field in required_fields):
        return jsonify({"error": "Missing required fields: review_id or reason."}), 400

    # Validate reason against allowed values (for MVP, basic check)
    allowed_reasons = ["spam", "offensive", "fake", "irrelevant", "other"]
    if data['reason'] not in allowed_reasons:
        return jsonify({"error": f"Invalid reason provided. Must be one of: {', '.join(allowed_reasons)}"}), 400

    # Generate a unique report ID and timestamp
    report_id = str(uuid.uuid4())
    report_timestamp = datetime.utcnow().isoformat() + "Z"

    # Construct the event payload
    event_payload = {
        "report_id": report_id,
        "review_id": data['review_id'],
        "reason": data['reason'],
        "comment": data.get('comment'),
        "reporting_user_id": data.get('reporting_user_id'), # Assumed to be passed if user is logged in
        "report_timestamp": report_timestamp
    }

    # 2. Publish Event to Message Queue (Pseudocode)
    # try:
    #     mq_producer.publish(event_payload)
    #     print(f"Published customer abuse report event for report ID: {report_id}")
    # except Exception as e:
    #     print(f"Message queue error publishing report {report_id}: {e}")
    #     # Depending on criticality, might still return 202 but log prominently
    #     return jsonify({"error": "Report received but failed to publish for processing."}), 500
    print(f"Simulating MQ publish for customer report: {report_id}")


    return jsonify({"message": "Abuse report received and is being processed.", "report_id": report_id}), 202

if __name__ == '__main__':
    app.run(debug=True, port=5001)
